name: Daily ICC (after 16:00 US/Eastern)

on:
  workflow_dispatch:
    inputs:
      tickers:
        description: "Comma-separated tickers for sample run (leave blank for SP500)"
        required: false
        type: string
      start:
        description: "Start date (YYYY-MM-DD); default 2024-01-01"
        required: false
        type: string
      end:
        description: "End date (YYYY-MM-DD); default = today (UTC)"
        required: false
        type: string
  schedule:
    # ≈16:15 ET in DST (UTC-4)
    - cron: "15 20 * * *"
    # ≈16:15 ET in Standard Time (UTC-5)
    - cron: "15 21 * * *"

permissions:
  contents: write

concurrency:
  group: daily-icc
  cancel-in-progress: true  # cancel a second overlap

jobs:
  run-icc:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Mark workspace as safe
        run: git config --global --add safe.directory "$GITHUB_WORKSPACE"

      # DST-aware gate: only for **scheduled** runs (manual runs skip this step)
      - name: Decide if this scheduled run should proceed (DST-aware)
        if: ${{ github.event_name == 'schedule' }}
        id: gate
        shell: bash
        run: |
          python - <<'PY'
          from datetime import datetime, timezone
          from zoneinfo import ZoneInfo
          import os

          now_utc = datetime.now(timezone.utc)                   # aware
          now_et  = now_utc.astimezone(ZoneInfo("America/New_York"))
          # ET offset in hours: -4 (DST) or -5 (ST)
          off_hours = int(round(now_et.utcoffset().total_seconds()/3600))
          # 16:15 ET corresponds to these UTC hours:
          # allowed_utc_hour = 16 - off_hours  (-> 20 for -4, 21 for -5)
          allowed_utc_hour = (16 - off_hours) % 24

          skip = (now_utc.hour != allowed_utc_hour)
          with open(os.environ["GITHUB_OUTPUT"], "a") as f:
              f.write(f"skip={'true' if skip else 'false'}\n")
          PY

      - name: Set up Python
        if: ${{ github.event_name == 'workflow_dispatch' || steps.gate.outputs.skip == 'false' }}
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install dependencies
        if: ${{ github.event_name == 'workflow_dispatch' || steps.gate.outputs.skip == 'false' }}
        run: |
          python -m pip install --upgrade pip
          if [ -f requirements.txt ]; then
            pip install -r requirements.txt
          else
            pip install pandas numpy yfinance lxml html5lib requests tzdata python-dateutil
          fi

      # ---- Build JSON for SP500 or a manual-specified sample ----
      - name: Build JSON (prices + news) for SP500 or Sample
        if: ${{ github.event_name == 'workflow_dispatch' || steps.gate.outputs.skip == 'false' }}
        env:
          SAMPLE_TICKERS: ${{ inputs.tickers }}
          SAMPLE_START:   ${{ inputs.start }}
          SAMPLE_END:     ${{ inputs.end }}
        run: |
          set -euo pipefail
          export PYTHONPATH="src:${PYTHONPATH:-}"

          mkdir -p data apps/web/public/data

          if [ -n "${SAMPLE_TICKERS:-}" ]; then
            echo ">>> Sample mode for tickers: ${SAMPLE_TICKERS}"
            echo "ticker" > data/universe.csv
            for t in $(echo "$SAMPLE_TICKERS" | tr ',;' '  '); do
              printf "%s\n" "${t^^}" >> data/universe.csv
            done
            START="${SAMPLE_START:-2024-01-01}"
            END="${SAMPLE_END:-$(date -u +%Y-%m-%d)}"
          else
            echo ">>> Full SP500 mode"
            python -m market_sentiment.cli.build_universe --out data/universe.csv
            START="2024-01-01"
            END="$(date -u +%Y-%m-%d)"
          fi

          python -m market_sentiment.cli.build_json \
            --universe data/universe.csv \
            --start "$START" \
            --end   "$END" \
            --out   apps/web/public/data

      # Optional: inject daily news counts (n_finnhub+n_yfinance) into ticker JSONs
      - name: Aggregate daily news counts into ticker JSONs
        if: ${{ github.event_name == 'workflow_dispatch' || steps.gate.outputs.skip == 'false' }}
        run: |
          python tools/build_news_counts.py || true

      - name: Print repository file list to logs
        if: ${{ github.event_name == 'workflow_dispatch' || steps.gate.outputs.skip == 'false' }}
        run: |
          find . -type f | sort

      # Only commit when data/public files changed
      - name: Check for data changes
        if: ${{ github.event_name == 'workflow_dispatch' || steps.gate.outputs.skip == 'false' }}
        id: changes
        shell: bash
        run: |
          if git status --porcelain apps/web/public/data data | grep .; then
            echo "changed=true" >> "$GITHUB_OUTPUT"
          else
            echo "changed=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Commit & push (rebase-safe; only when changed)
        if: ${{ steps.changes.outputs.changed == 'true' }}
        shell: bash
        env:
          BRANCH_NAME: ${{ github.ref_name }}
        run: |
          set -euo pipefail
          BRANCH="${BRANCH_NAME:-main}"

          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          # Stage FIRST so worktree is clean before rebase
          git add -A apps/web/public/data data FILES.md || true

          if git diff --cached --quiet; then
            echo "No changes to commit."
            exit 0
          fi

          ts=$(date -u +"%Y-%m-%d")
          git commit -m "Daily ICC update ${ts} [skip ci]"

          git fetch origin "${BRANCH}"
          # Stash-around-rebase safety for rare edge cases
          git pull --rebase origin "${BRANCH}" || {
            git stash push --include-untracked -m "ci-auto" || true
            git pull --rebase origin "${BRANCH}"
            git stash pop || true
          }

          git push origin HEAD:"${BRANCH}" || {
            echo "Push failed; rebasing once more and retrying..."
            git pull --rebase origin "${BRANCH}"
            git push origin HEAD:"${BRANCH}"
          }
